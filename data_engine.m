clear;
clc;
close all;

% Set parallel parameters
max_workers = 4;                        % Maximum number of parallel workers (adjust according to system configuration)
min_workers = 2;                        % Minimum number of parallel workers
try
    delete(gcp('nocreate'));            % Close existing parallel pool
    parpool([min_workers max_workers]); % Create elastic parallel pool
catch
    fprintf('Parallel pool creation failed. Continuing in serial mode.\n');
end

% File path settings
cta_folder = 'all_image';  %original ImageCAS volume folder
mask_folder = 'combined_label'; % mask generated by totalsegmentor (For coronary artery, directly use the labels from ImageCAS)
output_folder = 'all_image_fake'; % output folder for fake NCCT images

% Structure parameters (must be serializable for parallel workers)
structureList = { ...   %make sure you have teh correct label mapping
    '123',                 35;   %aorta
    '128',                35; %coronary_arteries
    '62',                   35; %superior_vena_cava
    '118',                 50;   %heart_myocardium
    '119',                 40;   %heart_atrium_left
    '120',                 40;   %heart_ventricle_left
    '121',                 40;   %heart_atrium_right
    '122',                 40;   %heart_ventricle_right
    '63',                   35;    %inferior_vena_cava
    '61',                   40;    %atrial_appendage_left
    '5',                 55;  %liver
    '6',                 50;  %stomach
    '15',               40;  %esophagus
    '124',              35;     %pulmonary_artery  
    '53',               35;  %pulmonary_vein
};

params = struct(...
    'calc_ratio', 0.65,...
    'vessel_HU', 40,...
    'calc_HU', [300, 1000],...
    'noncalc_HU', [50, 150],...
    'num_plaques', randi([0, 15]));

% Get file list
cta_files = dir(fullfile(cta_folder, '*.nii.gz'));
total_files = length(cta_files);

% Main processing loop (keep serial debugging capability)
USE_PARALLEL = true;  % Parallel switch (set to false for debugging)
if USE_PARALLEL
    loop_type = 'parfor';
else
    loop_type = 'for';
end

% Use functional programming to improve parallel processing
feval(loop_type, 1:total_files, ...
    @process_single_file, ...
    cta_files, mask_folder, output_folder, structureList, params);

function process_single_file(idx, cta_files, mask_folder, output_folder, structureList, params)
    try
        tStart = tic;
        
        % File name processing
        [~, base_name, ~] = fileparts(cta_files(idx).name);
        cta_file = fullfile(cta_files(idx).folder, [num2str(idx), '.img.nii.gz']);
        mask_file = fullfile(mask_folder, [num2str(idx), '.label.nii.gz']);
        
        % Exception check
        if ~exist(cta_file, 'file') || ~exist(mask_file, 'file')
            fprintf('Missing file for case %d. Skipping...\n', idx);
            return;
        end

        % Read files
        [CTA_img, info] = read_nifti(cta_file);
        mask_img = read_nifti(mask_file);
        
        % Image processing workflow
        CT_img = apply_hu_variation(CTA_img, mask_img, structureList);
        R_2D_recon_volume = radon_reconstruction(CT_img);
        R_2D_recon_volume_plaque = add_plaque(R_2D_recon_volume, mask_img, params);
        
        % Save result
        save_result(R_2D_recon_volume_plaque, info, output_folder, idx);
        
        % Performance monitoring
        elapsedTime = toc(tStart);
        fprintf('[Case %d] Processed in %.2f seconds\n', idx, elapsedTime);
        
    catch ME
        fprintf('[Error in case %d] %s\n%s\n', idx, ME.message, getReport(ME));
    end
end

% The following are helper functions (each includes memory cleanup mechanism)
function [img, info] = read_nifti(filename)
    info = niftiinfo(filename);
    img = niftiread(info);
    img = single(img);  % Convert to single precision to save memory
end

function save_result(data, info, output_folder, idx)
    outputFile = fullfile(output_folder, [num2str(idx), '.img.nii']);
    niftiwrite(int16(data), outputFile, info);
    gzip(outputFile);
    delete(outputFile);
end

function CT_img = apply_hu_variation(CTA_img, mask_img, structureList)
    CT_img = CTA_img;
    for i = 1:size(structureList, 1)
        structID = str2double(structureList{i,1});
        structHU = structureList{i,2};
        if rand < 0.5
            structHU = structHU + (-200 + 400*rand);
        end
        maskIdx = mask_img == structID;
        se = strel('disk', 2);
        maskIdx = maskIdx | imdilate(maskIdx, se);
        CT_img(maskIdx) = structHU;% + (-50 + 100*rand(sum(maskIdx(:)),1));
    end
end

function R_2D_recon_volume = radon_reconstruction(CT_img)
    sigma = 0.5;
    theta = 0:1:179;
    R_2D_recon_volume = zeros(size(CT_img), 'single');
    for n = 1:size(CT_img,3)
        slice = imgaussfilt(CT_img(:,:,n), sigma);
        [R, ~] = radon(slice, theta);
        R_noisy = add_poisson_noise(R);
        recon = iradon(R_noisy, theta, 'linear', 'Ram-Lak', 1, size(slice,1));
        R_2D_recon_volume(:,:,n) = imgaussfilt(recon, 2);
    end
end

function noisy_data = add_poisson_noise(data)
    R_min = min(data(:));
    R_shifted = data - R_min;
    random_number = randi([10000, 100000]);
    R_norm = R_shifted / max(R_shifted(:)) * random_number;
    noisy_data = poissrnd(R_norm);
    noisy_data = double(noisy_data) / random_number * max(R_shifted(:)) + R_min;
end

function output_volume = add_plaque(input_volume, vessel_mask, params)
    % Plaque generation logic (keep original implementation here)
     [output_volume, ~] = generate_plaque(input_volume, vessel_mask, params);
end
